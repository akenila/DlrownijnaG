def create_poster_with_blurred_background(input_path, output_path, blur_radius=4, darken_factor=0.4):
    # Mở ảnh gốc
    original_img = Image.open(input_path)
    
    # Tính toán kích thước cho ảnh đầu ra tỷ lệ 16:9
    target_height = original_img.height
    target_width = int(target_height * 16 / 9)
    
    # Tạo ảnh nền (phiên bản phóng to và làm mờ)
    scale_factor = max(1, target_width / original_img.width)
    bg_width = int(original_img.width * scale_factor)
    bg_height = int(original_img.height * scale_factor)
    
    bg_img = original_img.resize((bg_width, bg_height), Image.LANCZOS)
    
    # Làm mờ hình nền
    bg_img = bg_img.filter(ImageFilter.GaussianBlur(radius=blur_radius))
    
    # Làm tối hình nền để ảnh chính nổi bật hơn
    enhancer = ImageEnhance.Brightness(bg_img)
    bg_img = enhancer.enhance(darken_factor)
    
    # Cắt nền để phù hợp với kích thước mục tiêu
    bg_x_offset = (bg_width - target_width) // 2
    bg_y_offset = (bg_height - target_height) // 2
    bg_img = bg_img.crop((bg_x_offset, bg_y_offset, 
                         bg_x_offset + target_width, 
                         bg_y_offset + target_height))
    
    # Tạo ảnh mới với nền đã xử lý
    result = Image.new("RGB", (target_width, target_height))
    result.paste(bg_img, (0, 0))
    
    # Giữ nguyên tỷ lệ khung hình gốc cho ảnh ở giữa
    foreground_height = target_height
    foreground_width = int(original_img.width * foreground_height / original_img.height)
    
    # Nếu chiều rộng lớn hơn khung, điều chỉnh lại
    if foreground_width > target_width:
        foreground_width = target_width
        foreground_height = int(original_img.height * foreground_width / original_img.width)
    
    # Điều chỉnh kích thước ảnh gốc cho phần hiển thị chính
    foreground_img = original_img.resize((foreground_width, foreground_height), Image.LANCZOS)
    
    # Tính toán vị trí để căn giữa ảnh
    position_x = (target_width - foreground_width) // 2
    position_y = (target_height - foreground_height) // 2
    
    # Đặt ảnh gốc lên kết quả
    result.paste(foreground_img, (position_x, position_y))
    
    # Lưu kết quả
    result.save(output_path)


# Set theme and default appearance
ctk.set_appearance_mode("dark")
ctk.set_default_color_theme("blue")

# Create main window
app = ctk.CTk()
app.title("Film Reup Tool")
app.geometry("600x400")
if os.path.exists("./SaveData")==False: os.mkdir("./SaveData")  
if os.path.exists("./ImageData")==False: os.mkdir("./ImageData")  
if os.path.exists("./VideoData")==False: os.mkdir("./VideoData")  
if os.path.exists("./Data")==False: os.mkdir("./Data")

global_proxy = {
    "http":"http://0JeLKc:G69qYC@hub-us-8.litport.net:31682",
    "https":"http://0JeLKc:G69qYC@hub-us-8.litport.net:31682"
}
# Create frame for better organization
frame = ctk.CTkFrame(app)
frame.pack(padx=20, pady=20, fill="both", expand=True)

# Create log text area (read-only)
log_text = ctk.CTkTextbox(frame, width=550, height=200)
log_text.pack(padx=10, pady=10)
log_text.configure(state="disabled")  # Make it read-only

# Create thread count input
thread_frame = ctk.CTkFrame(frame)
thread_frame.pack(fill="x", padx=10, pady=5)

thread_label = ctk.CTkLabel(thread_frame, text="Number of Threads:")
thread_label.pack(side="left", padx=5)

thread_entry = ctk.CTkEntry(thread_frame, width=100)
thread_entry.pack(side="left", padx=5)
thread_entry.insert(0, "1")  # Default value

video_num_frame = ctk.CTkFrame(frame)
video_num_frame.pack(fill="x", padx=10, pady=5)

video_num_label = ctk.CTkLabel(video_num_frame, text="Number of video_nums:")
video_num_label.pack(side="left", padx=5)

video_num_entry = ctk.CTkEntry(video_num_frame, width=100)
video_num_entry.pack(side="left", padx=5)
video_num_entry.insert(0, "1")  # Default value

# Create buttons frame
button_frame = ctk.CTkFrame(frame)
button_frame.pack(fill="x", padx=10, pady=10)

# File paths to store selected files
acc_file_path = ""  # Changed from list to string
acc_data = []       # New array to store account data
data_file_path = "" # Changed from list to string 
data_content = []   # New array to store data content

def load_acc_file():
    global acc_file_path, acc_data
    acc_file_path = filedialog.askopenfilename(title="Select Account File")
    if acc_file_path:
        try:
            with open(acc_file_path, 'r', encoding='utf-8') as f:
                acc_data = [line.strip() for line in f.readlines() if line.strip()]  # Remove empty lines
            if len(acc_data) == 0:
                update_log("Error: Account file is empty")
                acc_file_path = ""
                acc_data = []
                return
            update_log(f"Account file loaded: {acc_file_path}")
            update_log(f"Total accounts: {len(acc_data)}")
        except Exception as e:
            update_log(f"Error reading account file: {str(e)}")
            acc_file_path = ""
            acc_data = []

def load_data_file():
    global data_file_path, data_content
    data_file_path = filedialog.askopenfilename(title="Select Data File")
    if data_file_path:
        try:
            with open(data_file_path, 'r', encoding='utf-8') as f:
                data_content = [line.strip() for line in f.readlines() if line.strip()]  # Remove empty lines
            if len(data_content) == 0:
                update_log("Error: Data file is empty")
                data_file_path = ""
                data_content = []
                return
            update_log(f"Data file loaded: {data_file_path}")
            update_log(f"Total data: {len(data_content)}")
        except Exception as e:
            update_log(f"Error reading data file: {str(e)}")
            data_file_path = ""
            data_content = []

def login(data):
    email = data.split("|")[0]
    password = data.split("|")[1]
    update_log(f"Đang đăng nhập account {email}")
    token_login = ""
    global global_proxy
    while True:
        try:
            token_login = ""
            d = {"user_email":email,"client_type":3}

            h = {
                'Authorization':token_login,
                'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36 Edg/122.0.0.0',
                'X-Cdk-Dsid':'1b9be33b-2263-79b6-7da2-6fb5f24efc55',    
                'X-Cdk-Lrtm':'2024-03-15 20:57:36',
                'Accept':'application/json, text/plain, */*',
                'Accept-Encoding':'gzip, deflate, br',
                'Accept-Language':'vi,en-US;q=0.9,en;q=0.8',
                'Content-Length':'56',
                'Origin':'https://www.ganjingworld.com',
                'Referer':'https://www.ganjingworld.com/',
                'Sec-Ch-Ua':'"Chromium";v="122", "Not(A:Brand";v="24", "Microsoft Edge";v="122"',
                'Sec-Ch-Ua-Mobile':'?0',
                'Sec-Ch-Ua-Platform':'"Windows"',
            }
            a = requests.post("https://gw.ganjingworld.com/v1.0c/signinpw", headers=h, json=d, proxies=global_proxy)
            print(a.json())
            if "The user does not exist" in a.text:
                update_log(f"Account {email} không tồn tại")
                return None
            server_salt = a.json()["data"]["server_salt"]
            client_salt = a.json()["data"]["client_salt"]
            break
        except Exception as e:
            continue
    def hash_password(pss, client_salt, server_salt):
        x = hashlib.sha256((pss + client_salt).encode()).digest()
        x_base64 = base64.b64encode(x).decode()
        S = hashlib.sha256((x_base64 + server_salt).encode()).digest()
        S_base64 = base64.b64encode(S).decode()
        return S_base64

    hashed_password = hash_password(password, client_salt, server_salt)

    d = {"user_email":email,"password_hash":hashed_password,"client_type":3}

    h = {
        'Authorization':token_login,
        'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36 Edg/122.0.0.0',
        'X-Cdk-Dsid':'1b9be33b-2263-79b6-7da2-6fb5f24efc55',    
        'X-Cdk-Lrtm':'2024-03-15 20:57:36',
        'Accept':'application/json, text/plain, */*',
        'Accept-Encoding':'gzip, deflate, br',
        'Accept-Language':'vi,en-US;q=0.9,en;q=0.8',
        'Content-Length':'56',
        'Origin':'https://www.ganjingworld.com',
        'Referer':'https://www.ganjingworld.com/',
        'Sec-Ch-Ua':'"Chromium";v="122", "Not(A:Brand";v="24", "Microsoft Edge";v="122"',
        'Sec-Ch-Ua-Mobile':'?0',
        'Sec-Ch-Ua-Platform':'"Windows"',
    }
    while True:
        try:
            a = requests.post("https://gw.ganjingworld.com/v1.0c/signinpw", headers=h, json=d, proxies=global_proxy)
            print(a.json())
            if "Password is incorrect" in a.text:
                update_log(f"Password của account {email} không đúng")
                return None
            access_token = a.json()["data"]["token"]
            update_log(f"Đăng nhập account {email} thành công")
            return access_token
        except Exception as e: 
            print(f"Error login {str(e)}") 
            pass
def get_data_torrent(keyword):
    torrents = py1337x.Py1337x()
    data = []
    while True:
        try:
            results = torrents.search(keyword, page=1)
            for i in results.items:
                data.append(i.name + "|" + i.magnet_link+ "|" + i.thumbnail+ "|" + i.description)
            return data
        except Exception as e:
            pass
def download_image(url, folder="./ImageData", filename=None):
    try:
        response = requests.get(url, proxies=global_proxy)
        response.raise_for_status()  # Raise exception for bad status codes
        
        # Save the image
        filename = os.path.join(folder, filename) if filename else os.path.join(folder, f"{time.time()}.jpg")
        with open(filename, 'wb') as f:
            f.write(response.content)
            
        update_log(f"Image downloaded successfully: {filename}")
        return filename
    except Exception as e:
        update_log(f"Error downloading image: {str(e)}")
        return None
def download_torrent(magnet_link, thumbnail=None):
    # Create unique timestamp ID for this download
    name_file = str(int(time.time() * 1000))  # More unique with milliseconds
    
    # Process thumbnail
    download_image(thumbnail, filename=f"{name_file}.jpg")
    create_poster_with_blurred_background(f"./ImageData/{name_file}.jpg", f"./ImageData/{name_file}.jpg")
    update_log(f"Edited thumbnail: {name_file}.jpg")
    
    # Create unique directory for this download to avoid conflicts between threads
    unique_dir = os.path.join("./Data", f"temp_{name_file}")
    os.makedirs(unique_dir, exist_ok=True)
    
    output = f'{name_file}.mp4'
    final_output_path = os.path.join("./VideoData", output)
    
    update_log(f"Downloading torrent to {unique_dir}: {magnet_link}")
    
    # Download to the thread-specific directory
    aria2c_path = "./torrentconvert/aria2c.exe"
    subprocess.run([aria2c_path, 
                "--dir=" + unique_dir,  # Use thread-specific directory 
                "--seed-time=0", 
                "-s16", "-x16", "--bt-max-peers=200",
                "--file-allocation=none",
                "--bt-save-metadata",
                "--always-resume=false",
                "--check-integrity=false",
                "--allow-overwrite=true",
                "--timeout=600",
                "--max-tries=5",
                magnet_link], 
                timeout=3600)
    
    # Find video file in the unique directory
    video_extensions = ['.mp4', '.mkv', '.avi', '.mov', '.wmv']
    found_video_path = None
    largest_size = 0
    
    for root, _, files in os.walk(unique_dir):
        for file in files:
            file_path = os.path.join(root, file)
            if any(file.lower().endswith(ext) for ext in video_extensions):
                file_size = os.path.getsize(file_path)
                if file_size > largest_size:
                    largest_size = file_size
                    found_video_path = file_path
    
    if not found_video_path:
        update_log(f"No video found in download directory. Using expected path.")
        return final_output_path, f"./ImageData/{name_file}.jpg"
    
    # Use os.rename to move the file (works if on same drive)
    try:
        os.rename(found_video_path, final_output_path)
        update_log(f"Moved video file to {final_output_path}")
    except OSError:
        # If fails (different drives), manually copy and delete using os functions
        with open(found_video_path, 'rb') as src_file:
            with open(final_output_path, 'wb') as dst_file:
                chunk_size = 1024 * 1024  # 1MB chunks
                while True:
                    chunk = src_file.read(chunk_size)
                    if not chunk:
                        break
                    dst_file.write(chunk)
        os.remove(found_video_path)
        update_log(f"Copied video file to {final_output_path}")
    
    # Clean up the temporary directory - delete all files first
    try:
        for root, dirs, files in os.walk(unique_dir, topdown=False):
            for file in files:
                os.remove(os.path.join(root, file))
            for dir in dirs:
                os.rmdir(os.path.join(root, dir))
        os.rmdir(unique_dir)
    except Exception as e:
        update_log(f"Warning: Could not clean up temp directory: {str(e)}")
        
    return final_output_path, f"./ImageData/{name_file}.jpg"

def get_language_code(language):
    language_codes = {
        "Vietnamese": "vi-VN",
        "English": "en-US",
        "Taiwanese": "zh-TW",
        "Chinese": "zh-CN",
        "Japanese": "ja-JP",
        "Korean": "ko-KR",
        "German": "de-DE",
        "Spanish": "es-ES",
        "French": "fr-FR",
        "Indonesian": "id-ID",
        "Italian": "it-IT",
        "Russian": "ru-RU",
    }
    return language_codes.get(language, "vi-VN")
def check_category(text):
    if text in [f"cat{i}" for i in range(1, 34)]:
        return text
    elif text=="cat32":
        return "cat10"
    return "cat10"

def get_webp_url(media_list):
            for url in media_list:
                if url.endswith('origin.webp'):
                    return url
            return None

def upload_in_chunks(email, file_path, upload_url, update_token, chunk_size=10*1000*1000):  # 10MB chunks
    file_size = os.path.getsize(file_path)
    offset = 0
    
    with open(file_path, 'rb') as f:
        while offset < file_size:
            f.seek(offset)
            chunk = f.read(chunk_size)
            
            # Configure retry parameters
            max_retries = 10
            retry_count = 0
            retry_delay = 3  # Start with 3 seconds delay
            
            # Keep trying this chunk until success or max retries reached
            while retry_count <= max_retries:
                headers = {
                    'Authorization': f'Bearer {update_token}',
                    'Content-Type': 'application/offset+octet-stream',
                    'Upload-Offset': str(offset),
                    'Tus-Resumable': '1.0.0',
                }
                
                update_log(f"[{email}] Uploading chunk: {offset}-{offset+len(chunk)} of {file_size} (Attempt {retry_count+1})")
                
                try:
                    response = requests.patch(
                        upload_url,
                        headers=headers,
                        data=chunk,
                    )
                    
                    if response.status_code == 204:
                        new_offset = int(response.headers.get("upload-offset", offset))
                        update_log(f"[{email}] Successfully uploaded: {new_offset} bytes")
                        offset = new_offset
                        break  # Success! Move to the next chunk
                    elif response.status_code == 409:  # Conflict
                        update_log(f"[{email}] 409 Conflict: Server and client offsets don't match")
                        # Try to get current server offset
                        try:
                            head_response = requests.head(upload_url, headers={'Authorization': f'Bearer {update_token}'})
                            if head_response.status_code == 200 and 'upload-offset' in head_response.headers:
                                server_offset = int(head_response.headers['upload-offset'])
                                update_log(f"[{email}] Server reports offset: {server_offset}")
                                offset = server_offset
                                break  # Reset and try with correct offset
                        except Exception:
                            pass  # If HEAD request fails, continue with normal retry
                    elif response.status_code == 504:  # Gateway Timeout
                        update_log(f"[{email}] 504 Gateway Timeout: Server is processing slowly")
                        # Use longer delay for timeouts
                        timeout_delay = retry_delay * 2
                        update_log(f"[{email}] Waiting {timeout_delay} seconds before retry...")
                        time.sleep(timeout_delay)
                        retry_delay = min(retry_delay * 2, 120)  # Longer max delay for timeouts (2 minutes)
                    elif response.status_code == 413:  # Request Entity Too Large
                        update_log(f"[{email}] 413 Error: Reducing chunk size and retrying")
                        chunk_size = chunk_size // 2
                        if chunk_size < 1024*1024:  # Don't go below 1MB
                            chunk_size = 1024*1024
                        break  # Break retry loop to re-read with smaller chunk size
                    else:
                        update_log(f"[{email}] Error uploading chunk: {response.status_code}")
                        retry_count += 1
                        
                        if retry_count > max_retries:
                            update_log(f"[{email}] Max retries exceeded for chunk at offset {offset}")
                            return False
                            
                        update_log(f"[{email}] Retrying in {retry_delay} seconds...")
                        time.sleep(retry_delay)
                        retry_delay = min(retry_delay * 2, 60)  # Exponential backoff, max 60 seconds
                        
                except requests.exceptions.Timeout:
                    update_log(f"[{email}] Request timed out")
                    retry_count += 1
                    # Use longer delay for timeouts
                    timeout_delay = retry_delay * 2
                    update_log(f"[{email}] Waiting {timeout_delay} seconds before retry...")
                    time.sleep(timeout_delay)
                    retry_delay = min(retry_delay * 2, 120)  # Longer max delay for timeouts
                except Exception as e:
                    update_log(f"[{email}] Exception during upload: {str(e)}")
                    retry_count += 1
                    
                    if retry_count > max_retries:
                        update_log(f"[{email}] Max retries exceeded for chunk at offset {offset}")
                        return False
                        
                    update_log(f"[{email}] Retrying in {retry_delay} seconds...")
                    time.sleep(retry_delay)
                    retry_delay = min(retry_delay * 2, 60)  # Exponential backoff, max 60 seconds
            
            # If we've exhausted all retries without success, exit
            if retry_count > max_retries:
                return False
                
            # Small pause between chunks on success
            time.sleep(1)
            
    return True

def upload_video(token, title, description, video_path, url_poster, lang, cat, email, password):
    global global_proxy, total
    update_log(f"[{email}:{password}] upload video {video_path}")
    lang = get_language_code(lang)
    cat = check_category(cat)
    h = {
        'Accept-Encoding':'gzip, deflate, br, zstd',
        'Authorization':token
    }
    while True:
        try:
            info = requests.post("https://gw.ganjingworld.com/v1.0c/getuserprofile", headers=h, proxies=global_proxy).json()
            profile_id = info["data"]["user_profile"]["profileId"]
            break
        except Exception as e:
            pass
    try:
        d = {
            "id":"",
            "type":"Video",
            "title":title,
            "description":description,
            "poster_url":"",
            "poster_hd_url":"",
            "meta":{
                "video_status":"uploading",
                "video_id":"","video_url":"",
                "video_filename":"a.mp4"
                },
            "price":0,
            "premium":0,
            "visibility":"public",
            "category_id":cat,
            "lang":lang,
            "mode":"draft",
            "version":0,
            "priority":"high",
            "comment_disabled":False,
            "keywords":[],
            "liveRedirect":{},
            "livechat_disabled":True,
            "set_as_premiere":False,
            "profile":"fullbitrate",
            "user_id2":profile_id,
            "time_scheduled":int(time.time()*1000),
            "variant":{
                "default":{
                    "buy_info":{"price":""},
                    "rent_info":{"price":""}
                            }
                        }
            }
    except Exception as e:
        tb = e.__traceback__
        error_message = f"Exception: {e} | "
        while tb is not None:
            filename = tb.tb_frame.f_code.co_filename
            lineno = tb.tb_lineno
            function_name = tb.tb_frame.f_code.co_name
            error_message += f"File: {filename}, Line: {lineno}, in {function_name}\n"
            tb = tb.tb_next
        open("error.txt", "a").write(error_message)
        return None
    while True:
        try:
            a = requests.post("https://gw.ganjingworld.com/v1.0c/add-content", headers=h, json=d, proxies=global_proxy).json()
            if a["result"]["message"]!="Ok":
                return None
            break
        except Exception as e:
            print(f"Error add content {str(e)}")
            pass
    update_log(f"[{email}:{password}] Đã tạo video {title}")
    content_id = a["data"]["id"]
    print(content_id)
    update_token = requests.get(f"https://gw.ganjingworld.com/v1.1/get-vod-token?content_id={content_id}", headers=h).json()["data"]["token"]
    print(update_token)

    # Đọc file video
    with open(video_path, 'rb') as f:
        file_content = f.read()
    # Tạo yêu cầu POST để khởi tạo việc tải lên
    response = requests.post(
        'https://vodapi.cloudokyo.cloud/api/v1/tus/upload',
        headers={
            'Authorization': f'Bearer {update_token}',
            'Upload-Length': str(len(file_content)),  # Kích thước của file
            'Tus-Resumable': '1.0.0',
            "Upload-Metadata":"parent_folders MWdsMGt0a2duaWo3eFpLRTdPWnRkSXZhTTFyZDB1,filename YjA5YTQ3MTItMDczYy00ZTVhLTg0YTktNDMyNjY2Y2Q1N2Q2X3ZpZGVvX21wNC5tcDQ=,filetype dmlkZW8vbXA0,profile_name ZnVsbGJpdHJhdGU=,auto_caption_flag ZmFsc2U=,preview_start MDA6MDA6MDA=,preview_end MDA6MDA6MjA=,priority aGlnaA==,content_type VmlkZW8=,content_id MWdtaTg0NWplMXQ2RnJ1b2NScUltQXRLRjFmbzFj,language ZW4tVVM=,analyze_flag dHJ1ZQ==,channel_id MWdsMGt1MGNqaDU3MlBLTkhxVzY1NFpHQjFvczBj"
        }
    )

    # Lấy URL để tải lên từ phản hồi
    upload_url = response.headers['Location']

    # Tải lên file video bằng yêu cầu PATCH
    update_log(f"[{email}:{password}] Đang upload video {title}")
    success = upload_in_chunks(email, video_path, upload_url, update_token)
    if success:
        update_log(f"[{email}:{password}] upload video {title} success")
    else:
        update_log(f"[{email}:{password}] upload video {title} failed")
        return None
    

    while True:
        try:
            a = requests.get(upload_url, headers={'Authorization':f"Bearer {update_token}"}, proxies=global_proxy).json()
            id_video = a['body']["video_id"]
            break
        except:
            pass
    while True:
        try:
            wait = requests.get(f"https://vodapi.cloudokyo.cloud/api/v1/status/{id_video}", headers={'Authorization':f"Bearer {update_token}"}, proxies=global_proxy).json()
            wait["body"]
        except:
            time.sleep(3)
            continue

        try:
            url_video = wait["body"]["url"]
            print(url_video)
            break
        except:
            update_log(f'[{email}:{password}] video upload thành công {wait["body"]["progress"]}%\n')
            pass
    update_log(f'[{email}:{password}] upload thành công video\n')
    update_log(f'[{email}:{password}] đang upload thumbnail\n')
    while True:
        try:
            b =  requests.post("https://imgapi.cloudokyo.cloud/api/v1/image", files={'file': (url_poster, open(url_poster, "rb"), f'image/{str(os.path.splitext(url_poster)[1]).replace(".","")}')}, headers={"Authorization":f"Bearer {update_token}"}, proxies=global_proxy).json()
            print(b)
            img_list =b["body"]["image_url"]
            url_poster = get_webp_url(img_list)
            break
        except Exception as e:
            print(f"error upload image {str(e)}")
            pass
    d = '{"id":"'+content_id+'","poster_url":"'+url_poster+'","meta":{"video_status":"ready","video_id":"'+str(id_video)+'","video_filename":"a.mp4","hidden":false,"video_url":"'+url_video+'","featured_video":"","encrypt_method":"","duration":0,"original_duration":0}}'

    up_video = requests.post("https://gw.ganjingworld.com/v1.0c/update-content", headers={'Authorization':token,"Accept":"application/json","Accept-Encoding":"gzip, deflate, br, zstd"}, json=json.loads(d))
    print(up_video.json()) 
    if up_video.json()["result"]["message"]=="Ok":
        update_log(f"[{email}:{password}] Upload video {title} thành công")
        total +=1
        return True


def get_random_movie(api_key: str, genre: str):
    # Dictionary of common genres and their TMDb IDs
    genres = {
        "action": 28,
        "comedy": 35,
        "drama": 18,
        "horror": 27,
        "romance": 10749,
        "science_fiction": 878,
        "thriller": 53
    }

    try:
        genre_id = genres.get(genre.lower())
        if not genre_id:
            raise ValueError(f"Genre '{genre}' not found")

        # Get a random page (1-5)
        page = random.randint(1, 100)
        
        # Make API request
        base_url = "https://api.themoviedb.org/3"
        url = f"{base_url}/discover/movie"
        params = {
            "api_key": api_key,
            "with_genres": genre_id,
            "page": page,
            "include_adult": False,
            "language": "en-US",
            "vote_count.gte": 100  # Only get movies with at least 100 votes
        }
        
        response = requests.get(url, params=params)
        response.raise_for_status()
        
        movies = response.json()["results"]
        if not movies:
            return None
        
        # Select random movie from results
        movie = random.choice(movies)
        
        # Get IMDB ID
        movie_id = movie["id"]
        movie_url = f"{base_url}/movie/{movie_id}/external_ids"
        movie_response = requests.get(movie_url, params={"api_key": api_key})
        movie_response.raise_for_status()
        
        imdb_id = movie_response.json()["imdb_id"]
        poster_path = movie.get("poster_path")
        thumbnail_url = None
        if poster_path:
            thumbnail_url = f"https://image.tmdb.org/t/p/w500{poster_path}"
        print(f"thumbnail_url: {thumbnail_url}")
        
        return {
            "title": movie["title"],
            "imdb_id": imdb_id,
            "release_date": movie["release_date"],
            "thumbnail_url": thumbnail_url
        }
        
    except Exception as e:
        print(f"Error: {str(e)}")
        return None
def get_movie_with_torrent_and_subtitle(genre, lock):
    # TMDb API Key
    tmdb_api_key = "3156a0847ba7024e5c7f5bd8e60ff1c6"
    
    # Step 1: Get random movie based on genre
    movie = get_random_movie(tmdb_api_key, genre)
    if not movie:
        return {"error": f"No movie found for genre: {genre}"}
    
    movie_title = movie["title"]
    imdb_id = movie["imdb_id"]
    release_year = movie["release_date"].split("-")[0]
    thumbnail_url = movie["thumbnail_url"]
    
    update_log(f"Found movie: {movie_title} ({release_year})")
    
    # Step 2: Search for torrent using py1337x
    torrent_link = None
    while True:
        try:
            update_log(f"Searching for torrent: {movie_title}")
            # Initialize torrent client
            torrent = Py1337x()
            
            # Search for movie torrent
            search_query = f"{movie_title}"
            print(f"Searching for torrent: {search_query}")
            results = torrent.search(search_query, category="Movies")
            
            if results.items:
                # Get first torrent result
                torrent_details = results.items[0]

                torrent_link = torrent.info(torrent_id=torrent_details.torrent_id)
                magnet_link = torrent_link.magnet_link
                title = torrent_details.name
                des = torrent_link.description

            break
        except Exception as e:
            pass
        time.sleep(5)
    update_log(f"Found torrent: {movie_title}")
    # Step 3: Get subtitles from OpenSubtitle
    if "https://" in torrent_link.thumbnail or "http://" in torrent_link.thumbnail:
        thumbnail_url = torrent_link.thumbnail   
    else:
        thumbnail_url = movie["thumbnail_url"]                                                                                                                                                 
    return {                                                                                                                                                
        "title": title,
        "magnet": magnet_link,
        "thumbnail": thumbnail_url,                    
        "description": des
    } 
def format_time(td):
    total_seconds = int(td.total_seconds())
    hours = total_seconds // 3600
    minutes = (total_seconds % 3600) // 60
    seconds = total_seconds % 60
    milliseconds = td.microseconds // 1000
    return f"{hours:02d}:{minutes:02d}:{seconds:02d},{milliseconds:03d}"

def login_post(lock):
    threads = int(thread_entry.get())
    global acc_data
        # Get unique account using lock
    def run(lock):
        while True:
            with lock:
                if not acc_data:
                    update_log("No more accounts available")
                    return
                acc = acc_data.pop()  # Remove and get account
                update_log(f"Processing with account: {acc.split('|')[0]}")
            num_video = int(video_num_entry.get())
            for i in range(num_video):
                genre = acc.split("|")[2]
                update_log(f"{acc.split('|')[0]}:Getting movie with torrent and subtitle...")
                data = get_movie_with_torrent_and_subtitle(genre, lock)
                update_log(f"{acc.split('|')[0]}:Get movie success")
                token = login(acc)
                thumnbail = data["thumbnail"]
                name = data["title"]
                magnet = data["magnet"]
                description = data['description']
                update_log(f"{acc.split("|")}:Downloading {name}...")
                video_path, url_poster = download_torrent(magnet, thumnbail)
                update_log(f"{acc.split('|')[0]}:Download {name} success")
                lang = acc.split("|")[3]
                cat = acc.split("|")[4]
                email = acc.split("|")[0]
                password = acc.split("|")[1]
                upload_video(token, name, description, video_path, url_poster, lang, cat, email, password)
    for i in range(threads):
        threading.Thread(target=run, args=(lock,)).start()


def start_process():
    global acc_data, data_content
    def run():
        lock = threading.Lock()
        try:
            threads = int(thread_entry.get())
            if threads <= 0:
                update_log("Error: Number of threads must be positive")
                return
        except ValueError:
            update_log("Error: Thread count must be a valid integer")
            return

        # Check if files are selected
        if not acc_file_path:
            update_log("Error: Please select an account file")
            return
        update_log(f"Starting process with {threads} threads...")
        
        threading.Thread(target=login_post, args=(lock,)).start()

    threading.Thread(target=run).start()


def update_log(message):
    log_text.configure(state="normal")
    log_text.insert("end", message + "\n")
    log_text.see("end")
    log_text.configure(state="disabled")

# Create buttons
load_acc_btn = ctk.CTkButton(button_frame, text="Load Account File", command=load_acc_file)
load_acc_btn.pack(side="left", padx=5)

start_btn = ctk.CTkButton(button_frame, text="Start", command=start_process)
start_btn.pack(side="left", padx=5)

# Start the application
if __name__ == "__main__":
    app.mainloop()
